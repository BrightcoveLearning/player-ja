<video id="myPlayerID"
data-video-id="6010362248001"
data-account="1752604059001"
data-player="default"
data-embed="default"
data-application-id
class="video-js"
controls></video>
<script src="//players.brightcove.net/1752604059001/default_default/index.min.js"></script>

<script>
  videojs.getPlayer（ "myPlayerID"）。ready（function（）{ // Create variables and new div, anchor and image for download icon var myPlayer = this, videoName, totalRenditions, mp4Ara = [], highestQuality, spacer, newElement = document.createElement("div"), newImage = document.createElement("img"); myPlayer.on("loadstart", function() { //Reinitialize array of MP4 renditions in case used with playlist //This prevents the array having a cumulative list for all videos in playlist mp4Ara = []; // +++ Get video name and the MP4 renditions +++ videoName = myPlayer.mediainfo["name"]; videoName = removeSpaces(videoName); rendtionsAra = myPlayer.mediainfo.sources; console.table(rendtionsAra) totalRenditions = rendtionsAra.length; // +++ Loop over videos and extract only MP4 versions +++ for (var i = 0; i &lt; totalRenditions; i++) { if ( rendtionsAra[i].container === "MP4" &amp;&amp; rendtionsAra[i].hasOwnProperty("src") ) { mp4Ara.push(rendtionsAra[i]); } } // +++レンディションをサイズの高いものから低いものへとソートします+++ mp4Ara.sort（function（a、b）{ return b.size - a.size; }）; console.table（mp4Ara）// +++最高のレンディションを抽出します+++ highestQuality = mp4Ara [0] .src; // +++ダウンロード画像要素をビルドします+++ newElement.id = "downloadImage"; newElement.className = "vjs-control downloadStyle"; newImage.setAttribute（ "src"、 "https://solutions.brightcove.com/bcls/brightcove-player/download-video/file-download.png"）; newImage.style ["cursor"] = "ポインタ"; // +++画像をクリックすると、ダウンロード関数を呼び出します+++ newImage.onclick = function（）{ // The download function forces download by the browsers // NOT opening the video in a new window/tab var x = new XMLHttpRequest(); x.open("GET", highestQuality, true); x.responseType = "blob"; x.onload = function(e) { download(x.response, videoName, "video/mp4"); } ; x.send（）; //}; newElement.appendChild（newImage）; // +++ダウンロード画像を配置します+++ //スペーサー要素のハンドルを取得しますspacer = myPlayer.controlBar.customControlSpacer.el（）; //スペーサーのコンテンツを右揃えに設定しますspacer.setAttribute（ "style"、 "justify-content：flex-end;"）; //新しい要素をスペーサーspacer.appendChild（newElement）;に配置します}）; }）; / **文字列からスペースを削除します* @ param {String}処理するstr文字列* @ return {String}トリミングされた文字列* / function removeSpaces（str）{ str = str.replace(/\s/g, ""); return str; } //download.js v4.2、dandavisによる; 2008-2016。 [CCBY2]テスト/使用法についてはhttp://danml.com/download.htmlを参照してください// v1は、ローカルの名前のないファイルに文字列をダウンロードするFF + Chrome互換の方法を採用し、隠しフレームとオプションのmimeを使用するようにアップグレードしました// v2は、[ダウンロード]、msSaveBlob、IE（10+）サポート、およびwindow.URLを介して名前付きファイルを追加しました。dataURLよりも大きく+高速な保存をサポートします。強制ダウンロードmimeとbase64のサポートにより改善されました。3.1 サファリの処理が改善されました。//v4 は AMD/UMD、CommonJS、およびプレーンブラウザのサポートを追加//v4.1 ソロの URL 引数 (同じドメイン/CORS のみ) によるURLのダウンロード機能を追加します//v4.2 セマンティック変数名、長い (2MB 以上) dataURL サポート、デフォルトの一時アンカーで非表示//https://github.com/rndme/download (function (ルート, ファクトリ) { if (typeof define === "function" &amp;&amp; define.amd) { // AMD. Register as an anonymous module. define([], factory); } else if (typeof exports ==「オブジェクト」) { // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(); } else { // Browser globals (root is window) root.download = factory(); } }) (これ, 関数 () { return function download(data, strFileName, strMimeType) { var self = window, // this script is only for browsers anyway... defaultMime = "application/octet-stream", // this default mime also triggers iframe downloads mimeType = strMimeType || defaultMime, payload = data, url = !strFileName &amp;&amp; !strMimeType &amp;&amp; payload, anchor = document.createElement("a"), toString = function(a) { return String(a); } , myBlob = self.blob || self.mozblob || self.webkitBlob || toString, filename = strFileName || " download」, blob, reader; myBlob = myBlob.call？MyBlob.bind (自己):blob; if (文字列 (これ) ===「真」) { //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback payload = [payload, mimeType]; mimeType = payload[0]; payload = payload[1]; } if (url &amp;url.length  &lt;  2048) { // if no filename and no mime, assume a url was passed as the only argument fileName = url .split("/") .pop() .split("?")[0]; anchor.href = url; // assign href prop to temp anchor if (anchor.href.indexOf(url) !== -1) { // if the browser determines that it's a potentially valid url path: var ajax = new XMLHttpRequest(); ajax.open("GET", url, true); ajax.responseType = "blob"; ajax.onload = function(e) { download(e.target.response, fileName, defaultMime); } ; setTimeout (関数 () { ajax.send(); } , 0);//戻り値を使用してカスタムAjaxヘッダーを設定できる:return ajax;}//有効なURLがあれば終了しますか}//url なら終わる？//先に進んで (/^data\: [\ w+\-] +\/[\ w+\-] + [,] /.test (ペイロード)) { if (payload.length &gt; 1024 * 1024 * 1.999 &amp;&amp; myBlob !== toString) { payload = dataUrlToBlob(payload); mimeType = payload.type || defaultMime; }そうでなければ{ return navigator.msSaveBlob // IE10 can't do a[download], only Blobs: ? navigator.msSaveBlob(dataUrlToBlob(payload), fileName) : saver(payload); // everyone else can save dataURLs un-processed } } //dataURLが渡された場合は終了？blob = MyBlob のペイロードインスタンス？ペイロード:新しい myBlob ([ペイロード], { type: mimeType } ); 関数 dataurlToBlob (strURL { var parts = strUrl.split(/[:;,]/), type = parts[1], decoder = parts[2] == "base64" ? atob : decodeURIComponent, binData = decoder(parts.pop()), mx = binData.length, i = 0, uiArr = new Uint8Array(mx); for (i; i &lt; mx; ++i) uiArr[i] = binData.charCodeAt(i); return new myBlob([uiArr], { type: type } );} 関数セーバー (url, WinMode) { if ("download" in anchor) { //html5 A[download] anchor.href = url; anchor.setAttribute("download", fileName); anchor.className = "download-js-link"; anchor.innerHTML = "downloading..."; anchor.style.display = "none"; document.body.appendChild(anchor); setTimeout(function() { anchor.click(); document.body.removeChild(anchor); if (winMode === true) { setTimeout(function() { self.URL.revokeObjectURL(anchor.href); } , 250);}}, 66); true を返す;}//非処理 [ダウンロード] サファリ我々はできるよう:もし (/(バージョン)\/(\ d+)\.(\ d+) (？:\。(\ d+))？。*Safari\ //.test (Navigator.UserAgent)) { url = url.replace(/^data:([\w\/\-\+]+)/, defaultMime); if (!window.open(url)) { // popup blocked, offer direct download: if ( confirm( "Displaying New Document\n\nUse Save As... to download, then click back to return to this page." ) ) { location.href = url; } } trueを返す;} //iframe DataURLのダウンロードを行う (古いch+FF): var f = document.createElement (「iframe」); document.body.appendChild (f); if (!WinMode) { // force a mime that will download: url = "data:" + url.replace(/^data:([\w\/\-\+]+)/, defaultMime); } f.src = url; setTimeout (function () { document.body.removeChild(f); } , 333);} //終了セーバー if (navigator.msSaveBlob) { // IE10+ : (has Blob, but not a[download] or URL) return navigator.msSaveBlob(blob, fileName); } if (self.url) { // simple fast and modern way using Blob and URL: saver(self.URL.createObjectURL(blob), true); } else { // handle non-Blob()+non-URL browsers: if (typeof blob === "string" || blob.constructor === toString) { try { return saver("data:" + mimeType + ";base64," + self.btoa(blob)); } catch (y) { return saver("data:" + mimeType + "," + encodeURIComponent(blob)); } } //ブロブただし、URLはサポートされていません:リーダー = new fileReader (); reader.onload = 関数 (e) { saver(this.result); } ; reader.readaSDataUrl (blob);} 真を返す;}; /* ダウンロード終了 () */});

</script>